import React, { useEffect, useRef, forwardRef, useImperativeHandle } from 'react';
import * as THREE from 'three';
import { MeasurementResult, UserStats } from '../types';

interface Props {
  measurements: MeasurementResult;
  stats: UserStats;
}

export interface BodyVisualizerHandle {
  downloadObj: () => void;
  downloadPng: () => void;
  getCanvas: () => HTMLCanvasElement | null;
}

export const BodyVisualizer = forwardRef<BodyVisualizerHandle, Props>(({ measurements, stats }, ref) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const groupRef = useRef<THREE.Group | null>(null);

  useImperativeHandle(ref, () => ({
    getCanvas: () => rendererRef.current?.domElement || null,
    downloadPng: () => {
      if (rendererRef.current && sceneRef.current) {
        // Render one last time to ensure latest state
        rendererRef.current.render(sceneRef.current, rendererRef.current.camera);
        const dataUrl = rendererRef.current.domElement.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'fit-twin-mannequin.png';
        link.href = dataUrl;
        link.click();
      }
    },
    downloadObj: () => {
      if (!groupRef.current) return;
      
      let output = "# Fit Twin 3D Export\n";
      output += `# Generated by AI Analysis\n`;
      
      let vertexOffset = 1;
      
      groupRef.current.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          const geometry = child.geometry;
          // Apply world matrix to get correct position/scale/rotation
          child.updateMatrixWorld();
          const matrix = child.matrixWorld;
          
          // Vertices
          const positionAttribute = geometry.attributes.position;
          for (let i = 0; i < positionAttribute.count; i++) {
            const vertex = new THREE.Vector3();
            vertex.fromBufferAttribute(positionAttribute, i);
            vertex.applyMatrix4(matrix);
            output += `v ${vertex.x.toFixed(4)} ${vertex.y.toFixed(4)} ${vertex.z.toFixed(4)}\n`;
          }
          
          // Normals (Optional, simplified export doesn't strictly need them for shape)
          
          // Faces
          const indexAttribute = geometry.index;
          if (indexAttribute) {
            for (let i = 0; i < indexAttribute.count; i += 3) {
              output += `f ${indexAttribute.getX(i) + vertexOffset} ${indexAttribute.getX(i+1) + vertexOffset} ${indexAttribute.getX(i+2) + vertexOffset}\n`;
            }
          } else {
            // Non-indexed geometry
            for (let i = 0; i < positionAttribute.count; i += 3) {
               output += `f ${i + vertexOffset} ${i + 1 + vertexOffset} ${i + 2 + vertexOffset}\n`;
            }
          }
          
          vertexOffset += positionAttribute.count;
        }
      });
      
      const blob = new Blob([output], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.download = 'fit-twin-model.obj';
      link.href = url;
      link.click();
    }
  }));

  useEffect(() => {
    if (!containerRef.current) return;

    // Setup
    const width = containerRef.current.clientWidth;
    const height = containerRef.current.clientHeight;
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff); // White background for clean export
    sceneRef.current = scene;

    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
    camera.position.set(0, 100, 300);
    camera.lookAt(0, 90, 0);
    // Store camera on renderer for reference in download functions if needed, 
    // but we usually pass it to render()
    
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      preserveDrawingBuffer: true // Required for toDataURL and printing
    });
    renderer.setSize(width, height);
    renderer.shadowMap.enabled = true;
    containerRef.current.innerHTML = '';
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;
    (renderer as any).camera = camera; // Hack to attach camera for imperative handle

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(50, 200, 100);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- BUILD MANNEQUIN ---
    const mannequinGroup = new THREE.Group();
    groupRef.current = mannequinGroup;
    scene.add(mannequinGroup);

    // Material
    const bodyMaterial = new THREE.MeshPhongMaterial({ 
      color: 0xe2e8f0, 
      transparent: true, 
      opacity: 0.9,
      shininess: 30,
      flatShading: false,
    });
    const wireframeMaterial = new THREE.MeshBasicMaterial({ 
      color: 0x94a3b8, 
      wireframe: true,
      transparent: true,
      opacity: 0.3
    });

    // Helper to create body part
    const createPart = (geometry: THREE.BufferGeometry, y: number, name: string) => {
      const mesh = new THREE.Mesh(geometry, bodyMaterial);
      mesh.position.y = y;
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      
      const wire = new THREE.Mesh(geometry, wireframeMaterial);
      wire.position.y = y;
      
      mannequinGroup.add(mesh);
      mannequinGroup.add(wire);
      return mesh;
    };

    // Measurement Ring Helper
    const createRing = (radius: number, y: number, color: number) => {
      const geometry = new THREE.TorusGeometry(radius + 0.5, 0.8, 8, 32);
      const material = new THREE.MeshBasicMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.x = Math.PI / 2;
      mesh.position.y = y;
      mannequinGroup.add(mesh);
      return mesh;
    };

    // Scale factors (Convert cm to world units, roughly 1 unit = 1 cm)
    // Height reference
    const h = stats.height;
    
    // 1. HEAD
    const headRadius = 12;
    const headY = h - headRadius;
    createPart(new THREE.SphereGeometry(headRadius, 32, 32), headY, 'head');
    createRing(headRadius, headY + 2, 0x22c55e); // Green Head Ring

    // 2. NECK
    const neckRadius = (measurements.neck || 38) / (2 * Math.PI);
    const neckHeight = 10;
    const neckY = headY - headRadius - (neckHeight/2) + 2;
    createPart(new THREE.CylinderGeometry(neckRadius, neckRadius, neckHeight, 32), neckY, 'neck');
    createRing(neckRadius, neckY, 0x6366f1); // Indigo Neck Ring

    // 3. TORSO
    // Shoulder
    const shoulderWidth = measurements.shoulder || 45;
    const shoulderY = neckY - (neckHeight/2) - 2;
    // Approximating shoulders as a capsule-like box or wider cylinder
    // Here using a horizontal cylinder for the yoke
    const yokeGeo = new THREE.CylinderGeometry(6, 6, shoulderWidth, 32);
    const yoke = new THREE.Mesh(yokeGeo, bodyMaterial);
    yoke.rotation.z = Math.PI / 2;
    yoke.position.y = shoulderY;
    mannequinGroup.add(yoke);
    
    // Chest
    const chestRadius = (measurements.chest || 100) / (2 * Math.PI);
    const chestHeight = 25;
    const chestY = shoulderY - 10;
    createPart(new THREE.CylinderGeometry(chestRadius * 1.1, chestRadius * 0.9, chestHeight, 32), chestY, 'chest');
    createRing(chestRadius * 1.1, chestY + 5, 0xd946ef); // Fuchsia Chest Ring

    // Waist
    const waistRadius = (measurements.waist || 80) / (2 * Math.PI);
    const waistHeight = 15;
    const waistY = chestY - (chestHeight/2) - (waistHeight/2);
    createPart(new THREE.CylinderGeometry(chestRadius * 0.9, waistRadius, waistHeight, 32), waistY, 'waist');
    createRing(waistRadius, waistY, 0x06b6d4); // Cyan Waist Ring

    // Hips
    const hipRadius = (measurements.hips || 95) / (2 * Math.PI);
    const hipHeight = 20;
    const hipY = waistY - (waistHeight/2) - (hipHeight/2);
    createPart(new THREE.CylinderGeometry(waistRadius, hipRadius, hipHeight, 32), hipY, 'hips');
    createRing(hipRadius, hipY, 0xeab308); // Yellow Hip Ring

    // 4. LEGS (Using Inseam)
    const legRadius = (measurements.thigh || 55) / (2 * Math.PI);
    const calfRadius = (measurements.calf || 38) / (2 * Math.PI);
    const ankleRadius = (measurements.ankle || 25) / (2 * Math.PI);
    const legLength = measurements.inseam || 75;
    const legSpacing = hipRadius * 0.8;

    const createLeg = (xDir: number) => {
      // Thigh
      const thighLen = legLength * 0.5;
      const thighY = hipY - (hipHeight/2) - (thighLen/2);
      const thighGeo = new THREE.CylinderGeometry(legRadius, calfRadius * 1.1, thighLen, 24);
      const thigh = createPart(thighGeo, thighY, 'thigh');
      thigh.position.x = xDir * legSpacing;
      // Thigh Ring
      const tr = createRing(legRadius, thighY + 5, 0x64748b); 
      tr.position.x = xDir * legSpacing;

      // Knee (Joint)
      const kneeY = thighY - (thighLen/2);
      const knee = new THREE.Mesh(new THREE.SphereGeometry(calfRadius * 1.1, 16, 16), bodyMaterial);
      knee.position.set(xDir * legSpacing, kneeY, 0);
      mannequinGroup.add(knee);

      // Calf/Shin
      const shinLen = legLength * 0.5;
      const shinY = kneeY - (shinLen/2);
      const shinGeo = new THREE.CylinderGeometry(calfRadius * 1.1, ankleRadius, shinLen, 24);
      const shin = createPart(shinGeo, shinY, 'shin');
      shin.position.x = xDir * legSpacing;
      // Calf Ring
      const cr = createRing(calfRadius, shinY + 5, 0x3b82f6);
      cr.position.x = xDir * legSpacing;

      // Ankle Ring
      const ar = createRing(ankleRadius, shinY - (shinLen/2) + 2, 0xa16207);
      ar.position.x = xDir * legSpacing;
    };

    createLeg(1);  // Right Leg
    createLeg(-1); // Left Leg

    // 5. ARMS
    const armRadius = (measurements.bicep || 35) / (2 * Math.PI);
    const forearmRadius = (measurements.wrist || 17) / (2 * Math.PI) * 1.5;
    const armLength = measurements.sleeve || 60; // Estimate total arm length if sleeve is shoulder to wrist
    
    const createArm = (xDir: number) => {
      const startX = (xDir * shoulderWidth/2);
      const startY = shoulderY;
      
      // Upper Arm
      const upperLen = armLength * 0.45;
      const upperY = startY - (upperLen/2);
      // Rotate arm slightly out A-Pose
      const angle = 0.3 * xDir; // radians
      
      const upperGeo = new THREE.CylinderGeometry(armRadius, armRadius * 0.8, upperLen, 24);
      const upperArm = createPart(upperGeo, 0, 'upperArm'); // Pos set by container
      
      const upperGroup = new THREE.Group();
      upperGroup.position.set(startX, startY, 0);
      upperGroup.rotation.z = -angle;
      upperGroup.add(upperArm);
      // Offset geometry locally so pivot is at top
      upperArm.position.y = -upperLen/2; 
      
      mannequinGroup.add(upperGroup);

      // Bicep Ring (Attached to group)
      const br = createRing(armRadius, -upperLen/3, 0x15803d);
      br.rotation.x = Math.PI/2; // Reset ring rotation relative to arm
      upperGroup.add(br);

      // Forearm
      const lowerLen = armLength * 0.55;
      const elbowY = -upperLen;
      
      const lowerGeo = new THREE.CylinderGeometry(armRadius * 0.8, forearmRadius, lowerLen, 24);
      const lowerArm = createPart(lowerGeo, 0, 'lowerArm');
      lowerArm.position.y = -lowerLen/2;
      
      const lowerGroup = new THREE.Group();
      lowerGroup.position.set(0, elbowY, 0);
      // Slight bend at elbow
      lowerGroup.rotation.z = -0.1 * xDir; 
      upperGroup.add(lowerGroup);
      lowerGroup.add(lowerArm);

      // Wrist Ring
      const wr = createRing(forearmRadius, -lowerLen + 2, 0xf97316);
      wr.rotation.x = Math.PI/2;
      lowerGroup.add(wr);
    };

    createArm(1);
    createArm(-1);

    // Floor
    const gridHelper = new THREE.GridHelper(200, 20, 0xddd6fe, 0xf1f5f9);
    gridHelper.position.y = 0;
    scene.add(gridHelper);

    // Animation Loop
    let animationId: number;
    const animate = () => {
      animationId = requestAnimationFrame(animate);
      mannequinGroup.rotation.y += 0.002; // Slow rotation
      renderer.render(scene, camera);
    };
    animate();

    // Cleanup
    return () => {
      cancelAnimationFrame(animationId);
      if (containerRef.current) {
        containerRef.current.innerHTML = '';
      }
      renderer.dispose();
    };
  }, [measurements, stats]);

  return (
    <div ref={containerRef} className="w-full h-full min-h-[400px] bg-white rounded-xl overflow-hidden cursor-move" />
  );
});

BodyVisualizer.displayName = "BodyVisualizer";
